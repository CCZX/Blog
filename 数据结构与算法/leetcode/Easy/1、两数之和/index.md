### 解题思路

#### 方法一：暴力破解

可以使用暴力破解的方式，但是时间复杂度为O(n^2)

#### 方法二：差值法

使用此方法需要新开辟一个内存空间来记忆之前数据与target的差值。

比如一组数列[1, 2, 3, 4]，target = 6，首先我们需要明白的是在数列中的每一项与target的差值分别为[5, 4, 3, 2]

1. 新建一个Map用于存储在遍历时数列项与target的差值，key为`target-nums[i]`，value为i（该项在原数列的索引）
2. 遍历数组，判断Map属性是否包含该项（nums[i]），如果包含的话就代表之前有一项加上该项之和等于target，所以返回之前项的索引和该项的索引即可（`return [Map[nums[i]], i]`）；如果Map属性不包含该项就代表之前没有值在加上该项之后和等于target，所以需要将target与该项的差作为Map的键，该项的索引作为值`（Map[target-nums[i]] = i）`
