## 1、浏览器渲染

先根据HTML生成一棵**DOM树**，在根据CSS样式表生成一棵**CSSOM**，然后将DOM和CSSOM合并为一棵**渲染树（RenderTree）**，然后通过**layout**计算各个元素的几何属性和位置，然后通过paint**渲染**。

**注意**：

- 浏览器采用的是**流式布局**
- 由于浏览器采用的是流式布局，对于**普通的渲染树只需要遍历一次，但是Table内部的元素会花费更多的时间**，这就是少用Table的原因

## 2、重绘（Repaint）、回流（重排、Reflow）

- 重绘

由于样式发生变化但是**不会影响布局**的，比如background-color、color、outline等属性变化。重绘的代价是高昂的，

- 回流

几何属性改**变影响到布局**的，回流是页面性能的重要指标，因为它**涉及到部分页面甚至整个页面的重新渲染**。一个元素的回流可能会导致其**子元素，兄弟元素、父元素的随后回流**。

- 避免重绘和回流

> CSS

1. 使用transform代替top（transform触发了GPU硬件加速），使用transform不会重新布局
2. 将动画元素设置position为absolute的元素上
3. 避免使用Table布局
4. 将频繁重绘或回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，如`will-change`、`video`、`iframe`
5. 避免使用CSS表达式
6. 避免多层内敛样式

> javascript

1. 避免频繁操作样式，最好一次性操作class属性
2. 避免频繁操作ＤＯＭ
3. 对于有复杂动画的元素使用绝对定位或者使用canvas



## 3、提升页面性能

### 1、资源压缩合并、减少HTTP请求

减少HTTP请求在CSS背景图方面可以使用**雪碧图**。

### 2、非核心代码异步加载

异步加载方式:

- 动态创建脚本
- defer
- async

defer、async区别：

- defer是在**HTML解析完成之后再执行，如果有多个则保持原来的顺序**；
- async是在**加载完成后就执行，不能保证顺序**

### 3、使用浏览器缓存

> 缓存位置

1. Service Worker：运行在浏览器背后的独立线程，可以用来实现缓存
2. Memory Cache：内存中的缓存，一旦页面关闭就消失了，内存小
3. DISK Cache：**磁盘中的缓存**，根据HTTP首部字段判断哪些资源可以缓存，哪些不可以缓存，哪些缓存过期。
4. Push Cache：只存在与会话中，一旦结束就被释放，并且缓存时间段。

> 缓存分类

1. **强缓存**：浏览器不会向服务器发送请求直接使用缓存中的资源。强缓存通过两种HTTP Header实现：Expires、Cache-Control。**Cache-Control优先级高于Expires**。

```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

表示资源在Wed, 22 Oct 2018 08:41:00 GMT后失效。

```http
Cache-Control:max-age=300
```

表示缓存在300s后失效

2. **协商缓存**：协商缓存会在强缓存失效后启用，浏览器携带标识符向服务器发送请求，服务器根据标识符来判断是否使用缓存。协商缓存通过设置两种 HTTP Header 实现：**Last-Modified和ETag**。

```http
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

**Last-Modified与if-Modified-Since配合使用**，当浏览器访问服务器一个资源的时候，**服务器会添加Last-Modified响应头**，当**浏览器**再次访问资源的时候，会添加**if-Modified-Since**请求头，值就是服务器上次返回的Last-Modified的值，服务器受到该请求，**如果if-Modified-Since与该资源最后修改日期相同则表示该资源没有修改**，可以直接使用返回**304**状态码。

```http
ETag: XXX
```

**ETag和if-None-Match配合使用，ETag是服务器响应请求时，返回当前文件的一个唯一标识符，只要资源变化就会重新生成**。当客户端第一次向服务器发起请求的时候，服务器会在**响应头添加一个ETag属性**，表示该资源的唯一标识，当客户端下一次访问该资源时，会添加**if-None-Match请求头**，值为上次的ETag值，服务器然后**将if-Node-Match值与该资源的ETag进行匹配，如果匹配相同则表示没有修改。**

### 4、使用CDN加速

CDN的全称是：`Content Delivery Network`，即内容分发网络。

CDN加速主要是针对一些**静态资源**，比如图片、CSS文件、JS文件等。CDN服务器通过缓存来实现资源的存储；**CDN是将网站的内容分发到最近的用户节点，当用户访问时就可以就近取得资源**，加快访问速度和成功率，优化用户体验，解决因分布、带宽、服务器性能带来的访问延迟的问题，适用于直播、站点加速等场景。

### 5、使用DNS（Domain Name System）优化

在前端优化中与 DNS 的有关一般有两点： 一个是**减少DNS的请求次数**，另一个就是进行**DNS预获取** 。

> DNS预解析

DNS全称为Domain Name System，即域名系统，是**域名和IP地址相互映射**的一个分布式数据库。

```html
// 打开和关闭DNS预读取
<meta http-equiv="x-dns-prefetch-control" content="off">
// 强制查询特定主机名
<link rel="dns-prefetch" href="//hm.baidu.com">
```

> DNS解析过程

1. 首先**浏览器缓存**是否有缓存该域名对应的IP；
2. 操作系统查看**本地hosts文件**；
3. **路由器缓存**；
4. **ISP（互联网服务提供商）DNS缓存**，比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；
5. **根域名服务器**，全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内**顶级域名（如.com）服务器**IP告诉本地DNS服务器；
6. **顶级域名服务器**，
7. **主域名服务器**
8. 保存结果至缓存

## 4、TCP/IP三次握手、四次挥手

### 1、三次握手

**三次握手保证了通信双方都具有数据收发的功能**

1. 客户端发送一个同步序列号SYN=1，初始序列号SEQ=N，连接服务器
2. 服务器返回确认号ACK=N+1，将同步序列号设置为SYN=1，并发送自己的序列号SEQ=M
3. 客服端返回确认号ACK=M+1，将同步序列号设置为SYN=0，然后返回序列号SEQ为第二次握手的确认号SEQ=N+1

如果只进行**两次握手会发生死锁**，因为在服务端发送给客户端ACK的过程中如果发生丢失，客户端会一直等待服务端的确认包，而服务端则认为客户端已经接收到了ACK，就会开始发送数据，而客户端会忽略服务端发来的数据只等待ACK。

### 2、四次挥手

**四次挥手来保证数据接收完毕**

1. 客户端A向服务端B发送一个FIN字段和SEQ=N序列号，来关闭客户端A到服务端B的数据传输
2. 服务端收到这个消息，发送一个ACK=N+1，和SEQ=M此时关闭链接进入waiting状态
3. 当服务器接收完数据之后，服务端发送FIN字段和ACK=N+1，SEQ=M给客户端
4. 客户端收到之后发送ACK=M+1和SEQ=N+1，等待2MSL后关闭连接

在**完成最后一次挥手之后需要等待2MSL**(Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”)，这样是为了防止发送的最后一个ACK包对方没有接收到，当对方没有接收到超时后会重新发送第三次挥手的FIN包当接收到FIN包之后可以再发送一个ACK。



## 5、常见浏览器内核

| 浏览器  |                             例子                             |
| :-----: | :----------------------------------------------------------: |
|   IE    |                   Trident内核，俗称IE内核                    |
| Chrome  | 统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核 |
| FireFox |                  Gecko内核，俗称Firefox内核                  |
| Safair  |                          Webkit内核                          |
|  Opera  |    最初是自己的Presto内核，后来是Webkit，现在是Blink内核     |

## 6、HTTP和HTTPS的区别

- HTTP的通信采用**明文传输**；**不能验证通信双方的身份**；**不能确保报文的完整性**。
- HTTPS采用**SSL安全套接字层**进行信息的交换。**SSL位于应用层和传输层之间**。
- 通过**对称加密以及非对称加密**可以解决明文传输的缺点，使用**第三方证书**来确认对方的身份，使用**数字签名**来确保报文的完整性。
- HTTP端口是80，HTTPS端口是443

> 常见对称加密算法和非对称加密算法

- 对称：DES、AES
- 非对称：RSA

## 7、HTTP1.0和HTTP2.0
​	HTTP2.0解决了HTTP1.1中长连接阻塞的问题。HTTP2.0采用的是**多路复用**的方式来解决该问题的，即在一个通路上可以可以让多条线路同时占用而不搞混淆，这里的作法是为**每一个请求带一个编号**，它让服务器方就能为请求的回应对上号了。如果一个请求时间过长，那么服务器就可以先暂停这个请求，先处理下一个请求，处理完再回来处理这个长请求，如果找回这个长请求呢，那就靠这个编号了。
​	除此之处，它还规定了HTTP传输的所有内容都转为**二进制进行传输**，以前的版本只有头部信息会转为二进制，内容体并不会。不统一总会造成额外的麻烦。比如内容是文本，而文本是有多种样式的，这样的话解析它的一方就很麻烦了，要支持你各种样式。

- 采用**二进制传输信息**，而非1.X的文本形式
- 异步链接**多路复用**
- 对**消息头采用Hpack进行压缩传输**，能够节省消息头占用的网络流量，http1.1每次请求，都会携带大量冗余的头信息，浪费了很多宽带资源。
- **Server Push**，服务器端能够更快的把资源推送到客户端。
- 保持与HTTP 1.1语义的向后兼容性也是该版本的一个关键。

## 8、Cookie、Session、WebStorage
在H5提供了两种在客户端存储数据的方法(即WebStorage包括localStorage和SessionStorage)
- localStorage：没有时间限制的数据存储
- SessionStorage：针对一个Session的数据存储
> 区别

|   |cookie| localstorage | SessionStorage |
|---|  ---  |--------------|----------------|
|生命周期|一般由服务端生成可以设置失效时间|永久保存除非删除| 仅在当前会话下有效，关闭页面或浏览器失效|
|数据大小|4k|5M|5M |
|与服务端通信|携带在HTTP请求头部|——| ——|
|易用性|||



## 10、同源策略

**协议、域名、端口全部一致才是同源**；同源策略限制了一个源如何从另一个源加载资源以及信息交互，同源策略是一个隔离恶意文件的关键性机制。

- Ajax不能发送
- DOM不能获取
- cookie不能获取

### 域名级别

- 一级域名：如`baidu.com`
- 二级域名：如`www.baidu.com`
- 类推。。。

## 11、跨域

> JSONP

**利用`script`标签没有同源策略限制**

```javascript
function jsonp(url) {
  let script = document.createElement('script)
  script.src = url
  document.bodo.appenChild(script)
}
function cb(data) {
  console.log(data)
}
jsonp('http://localhost:8080?cb=cb')
```

> CORS(跨域资源共享)

CORS需要浏览器和服务器的同时支持，CORS通信与同源的AJAX通信没有差别，代码完全一样。**浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求**，但用户不会有感觉。因此实现的**关键是服务端**。

浏览器将CORS请求分为**简单请求和非简单请求**。**简单请求发出CORS请求只需要在头信息中添加origin字段**；对于非简单请求浏览器会先发送一次**预请求**，询问服务器该域名是否在白名单内。

**只要同时满足以下两大条件，就属于简单请求。**
​	1) 请求方法是以下三种方法之一：(**简单请求之所以是简单请求是因为可以直接通过form表单来发送请求**)

- HEAD
- GET
- POST
2）HTTP的头信息不超出以下几种字段：
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

> nginx

代理
> Node

因为跨域不存在于服务端 

> webSocket

webSocket是全双工的

## 12、HTTP1.0、HTTP1.1、HTTP2.0

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上

> HTTP1.1：

- 缓存处理
- 长连接
- Host头处理
- 带宽优化及网络连接的使用

> HTTP2.0

- Header压缩
- 多路复用
- 二进制传输
- 服务端推送

## 13、TCP、UDP

1. TCP是面向连接的基于字节流的可靠连接，TCP只能点到点；
2. UDP是面向无连接的基于数据包的不可靠连接，UDP可以一对一、一对多、多对一、多对多。

通常在视频的传输过程使用UDP。TCP首部开销20字节;UDP的首部开销小，只有8个字节。

> TCP如何保证数据的可靠传输

4中拥塞控制算法：慢启动、拥塞避免、快速重传、快速恢复

> TCP首部开销

源端口号、目的端口号、序列号、确认号、数据偏移、保留、编码号、窗口、校验号、紧急、可选项、数据。

## 14、OSI七层模型

1. 应用层：文件传输、电子邮件、HTTP(80)、FTP(传输20、控制21)
2. 表示层：数据格式化、代码转换、数据加密
3. 会话层：解除或建立与别的节点的联系
4. 传输层：TCP、UDP
5. 网络层：IP、ICMP、IGMP
6. 数据链路层：传输有地址的帧以及错误检测，PPP、ARP（IP地址 -> Mac地址）、RARP
7. 物理层

## 15、TCP/IP四层模型

1. 应用层
2. 传输层
3. 网络层
4. 链路层

## 16、幂等性

`f(x)=f(f(x(f(x)..))`

HTTP方法的幂等性是指：**一次或多次请求一个资源的效果都是一样的**。如：GET、DELETE、PUT。

## 17、常见状态码

- 200成功
- 206范围请求，和Range请求头配合
- 301永久重定向
- 302临时重定向
- 304命中缓存
- 401未授权
- 403服务器拒接请求
- 404资源不存在
- 500内部服务器错误
- 502错误网关
- 503服务器过载
- 504网关超时

## 18、HTTP请求和响应

### 请求信息：

1. 请求行：请求方法、URI、协议、版本
2. 请求头：Content-Type、Cookie等
3. 空行
4. 请求体

### 响应信息

1. 状态行：200、404
2. 响应头：Content-Type、server、Date
3. 空行
4. 响应体

## 19、POST和GET区别

1. 传参方式不同：GET通过URL传参、POSt通过请求体传参
2. 参数限制不同：GET参数大小有限制、POST没有
3. POST比GET更安全
4. GET只接收ASCLL字符，POST接收任意字符
5. GET只支持URL编码，POST支持多种编码格式
6. GET回退无害、POST会重新提交
7. GET会被浏览器主动缓存、POST不会