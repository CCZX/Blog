## 1、浏览器渲染

先根据HTML生成一棵**DOM树**，在根据CSS样式表生成一棵**CSSOM**，然后将DOM和CSSOM合并为一棵**渲染树（RenderTree）**，然后通过**layout**计算各个元素的几何属性和位置，然后通过paint**渲染**。

**注意**：

- 浏览器采用的是**流式布局**
- 由于浏览器采用的是流式布局，对于**普通的渲染树只需要遍历一次，但是Table内部的元素会花费更多的时间**，这就是少用Table的原因

## 2、重绘（Repaint）、回流（重排、Reflow）

- 重绘

由于样式发生变化但是**不会影响布局**的，比如background-color、color、outline等属性变化。重绘的代价是高昂的，

- 回流

几何属性改**变影响到布局**的，回流是页面性能的重要指标，因为它**涉及到部分页面甚至整个页面的重新渲染**。一个元素的回流可能会导致其**子元素，兄弟元素、父元素的随后回流**。

- 避免重绘和回流

> CSS

1. 使用transform代替top（transform触发了GPU硬件加速）
2. 将动画元素设置position为absolute的元素上
3. 避免使用Table布局
4. 将频繁重绘或回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，如`will-change`、`video`、`iframe`
5. 避免使用CSS表达式
6. 避免多层内敛样式

> javascript

1. 避免频繁操作样式，最好一次性操作class属性
2. 避免频繁操作ＤＯＭ
3. 对于有复杂动画的元素使用绝对定位或者使用canvas



## 3、提升页面性能

### 1、资源压缩合并、减少HTTP请求

### 2、非核心代码异步加载

异步加载方式:

- 动态创建脚本
- defer
- async

defer、async区别：

- defer是在HTML解析完成之后再执行，如果有多个则保持原来的顺序
- async是在加载完成后就执行，不能保证顺序

### 3、使用浏览器缓存

> 缓存位置

1. Service Worker：运行在浏览器背后的独立线程，可以用来实现缓存
2. Memory Cache：内存中的缓存，一旦页面关闭就消失了，内存小
3. DISK Cache：磁盘中的缓存，根据HTTP首部字段判断哪些资源可以缓存，哪些不可以缓存，哪些缓存过期。
4. Push Cache：只存在与会话中，一旦结束就被释放，并且缓存时间段。

> 缓存分类

1. 强缓存：浏览器不会向服务器发送请求直接使用缓存中的资源。强缓存通过两种HTTP Header实现：Expires、Cache-Control。Cache-Control优先级高于Expires。

```http
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```

表示资源在Wed, 22 Oct 2018 08:41:00 GMT后失效。

```http
Cache-Control:max-age=300
```

表示缓存在300s后失效

2. 协商缓存：协商缓存会在强缓存失效后启用，浏览器携带标识符向服务器发送请求，服务器根据标识符来判断是否使用缓存。协商缓存通过设置两种 HTTP Header 实现：Last-Modified和ETag。

```http
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```

**Last-Modified与if-Modified-Since配合使用**，当浏览器访问服务器一个资源的时候，**服务器会添加Last-Modified响应头**，当**浏览器**再次访问资源的时候，会添加**if-Modified-Since**请求头，值就是服务器上次返回的Last-Modified的值，服务器受到该请求，**如果if-Modified-Since与该资源最后修改日期相同则表示该资源没有修改**，可以直接使用返回**304**状态码。

```http

```

**ETag和if-None-Match配合使用，ETag是服务器响应请求时，返回当前文件的一个唯一标识符，只要资源变化就会重新生成**。当客户端第一次向服务器发起请求的时候，服务器会在**响应头添加一个ETag属性**，表示该资源的唯一标识，当客户端下一次访问该资源时，会添加**if-None-Match请求头**，值为上次的ETag值，服务器然后**将if-Node-Match值与该资源的ETag进行匹配，如果匹配相同则表示没有修改。**

### 4、使用CDN

### 5、使用DNS预解析



## 4、TCP/IP三次握手、四次挥手

### 1、三次握手

**三次握手保证了通信双方都具有数据收发的功能**

1. 客户端发送一个同步序列号SYN=1，初始序列号SEQ=N，连接服务器
2. 服务器返回确认号ACK=N+1，将同步序列号设置为SYN=1，并发送自己的序列号SEQ=M
3. 客服端返回确认号ACK=M+1，将同步序列号设置为SYN=0，然后返回序列号SEQ为第二次握手的确认号SEQ=N+1

如果只进行两次握手会发生死锁，因为在服务端发送给客户端ACK的过程中如果发生丢失，客户端会一直等待服务端的确认包，
而服务端则认为客户端已经接收到了ACK，就会开始发送数据，而客户端会忽略服务端发来的数据只等待ACK。

### 2、四次挥手

**四次挥手来保证数据接收完毕**

1. 客户端A向服务端B发送一个FIN字段和SEQ=N序列号，来关闭客户端A到服务端B的数据传输
2. 服务端收到这个消息，发送一个ACK=N+1，和SEQ=M此时关闭链接进入waiting状态
3. 当服务器接收完数据之后，服务端发送FIN字段和ACK=N+1，SEQ=M给客户端
4. 客户端收到之后发送ACK=M+1和SEQ=N+1

在完成最后一次挥手之后需要等待2MSL，这样是为了防止发送的最后一个ACK包对方没有接收到，当对方没有接收到超时后会重新发送第三次挥手的FIN包当接收到FIN包之后可以再发送一个ACK



## 5、常见浏览器内核

| 浏览器  |                             例子                             |
| :-----: | :----------------------------------------------------------: |
|   IE    |                   Trident内核，俗称IE内核                    |
| Chrome  | 统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核 |
| FireFox |                  Gecko内核，俗称Firefox内核                  |
| Safair  |                          Webkit内核                          |
|  Opera  |    最初是自己的Presto内核，后来是Webkit，现在是Blink内核     |

## 6、HTTP和HTTPS的区别

HTTP的通信采用明文传输；不能验证通信双方的身份；不能确保报文的完整性。

HTTPS采用SSL安全套接字层进行信息的交换。SSL位于应用层和传输层之间。

通过对称加密以及非对称加密可以解决明文传输的缺点，使用第三方证书来确认对方的身份，使用数字签名来确保报文的完整性。

## 7、HTTP1.0和HTTP2.0
HTTP2.0解决了HTTP1.1中长连接阻塞的问题。HTTP2.0采用的是多路复用的方式来解决该问题的，即在一个通路上可以可以让多条线路同时占用而不搞混淆，这里的作法是为每一个请求带一个编号，它样服务器方就能为请求的回应对上号了。如果一个请求时间过长，那么服务器就可以先暂停这个请求，先处理下一个请求，处理完再回来处理这个长请求，如果找回这个长请求呢，那就靠这个编号了。
除此之处，它还规定了HTTP传输的所有内容都转为二进制进行传输，以前的版本只有头部信息会转为二进制，内容体并不会。不统一总会造成额外的麻烦。比如内容是文本，而文本是有多种样式的，这样的话解析它的一方就很麻烦了，要支持你各种样式。

- 采用二进制传输信息，而非1.X的文本形式
- 异步链接多路复用
- 对消息头采用Hpack进行压缩传输，能够节省消息头占用的网络流量，http1.1每次请求，都会携带大量冗余的头信息，浪费了很多宽带资源。
- Server Push，服务器端能够更快的把资源推送到客户端。
- 保持与HTTP 1.1语义的向后兼容性也是该版本的一个关键。


